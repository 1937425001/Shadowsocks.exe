DOM
  offsetWidth  width+padding+border+scroll
  clientWidth  width+padding
  scrollwidth  不存在scroll和clientWidth相同.存在scroll：子元素长度+padding
  
  em            单位基于使用他们元素的字体大小,受父元素限制
  rem           单位基于html元素的字体大小
  vmax          单位基于视口的的宽度或高度中较大的那个,其中最大的那个被均分为100单位的vmax
  vmin          单位基于视口的的宽度或高度中较小的那个,其中最小的那个被均分为100单位的vmin          
  vw            单位基于视口的宽度，均分为100份
  vh            单位基于视口的高度，均分为100份

JS

Array

sort          排序  (a,b) => a-b 从小到大   (a,b) => b-a 从大到小

---ES5

forEach        遍历数组
map            对数组每一项进行处理，返回一个新数组
filter         过滤原始数组，返回新数组
some           数组中某一个符合条件，即为true
every          数组中每一项都符合条件，即为true
reduce         对数组进行累计处理,合并为一个值
reduceRight    从右至左

----ES6

find           用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。
findIndex      返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。               这两个方法都可以识别NaN,弥补了indexOf的不足.
keys        
values 
entries
             for (let index of ['a', 'b'].keys()) {
                  console.log(index);
                }
                // 0
                // 1

                for (let elem of ['a', 'b'].values()) {
                  console.log(elem);
                }
                // 'a'
                // 'b'

                for (let [index, elem] of ['a', 'b'].entries()) {
                  console.log(index, elem);
                }
                // 0 "a"
                // 1 "b"

----ES7
includes       查找数组是否包含某个元素 返回布尔。为弥补indexOf
               includes方法是为了弥补indexOf方法的缺陷而出现的:

                indexOf方法不能识别NaN
                indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观
                
 Promise.all    接受的参数promise的数组,按照顺序发起，异步执行，不阻塞，其结果还是按照顺序映射到resultList中
                promise数组中任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象
 Promise.reace  接受的参数promise实例的数组,只要有一个实例resolve或者reject，就只返回该结果，其他实例不再执行。
 
 
Set 是无重复值的有序列表。根据 Object.is()方法来判断其中的值不相等，以保证无重复。 Set 会自动移除重复的值，
    因此你可以使用它来过滤数组中的重复值并返回结果。 Set并不是数组的子类型，所以你无法随机访问其中的值。但你可以
    使用has() 方法来判断某个值是否存在于 Set 中，或通过 size 属性来查看其中有多少个值。 Set 类型还拥有forEach()方法，用于处理每个值。


Weak Set 是只能包含对象的特殊 Set 。其中的对象使用弱引用来存储，意味着当 Weak Set中的项是某个对象的仅存引
        用时，它不会屏蔽垃圾回收。由于内存管理的复杂性， Weak Set的内容不能被检查，因此最好将 Weak Set 仅用于追踪
        需要被归组在一起的对象。


Map 是有序的键值对，其中的键允许是任何类型。与 Set 相似，通过调用 Object.is()方法来判断重复的键，这意味着能将
    数值 5 与字符串 "5" 作为两个相对独立的键。使用set() 方法能将任何类型的值关联到某个键上，并且该值此后能用 get()
    方法提取出来。Map 也拥有一个 size 属性与一个 forEach() 方法，让项目访问更容易。


Weak Map 是只能包含对象类型的键的特殊 Map 。与 Weak Set 相似，键的对象引用是弱引用，因此当它是某个对象的仅存
          引用时，也不会屏蔽垃圾回收。当键被回收之后，所关联的值也同时从 Weak Map 中被移除。

